/* VerseViewer.c generated by valac 0.48.9, the Vala compiler
 * generated from VerseViewer.vala, do not modify */

/* modules: gio-2.0 glib-2.0 gobject-2.0 gstreamer-1.0 gtk+-3.0*/

#include <gtk/gtk.h>
#include <glib.h>
#include <float.h>
#include <math.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>
#include <gst/gst.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk/gdk.h>
#include <glib/gstdio.h>
#include <gobject/gvaluecollector.h>

typedef enum  {
	COLUMN_sura
} Column;

#define TYPE_COLUMN (column_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_STREAM_PLAYER (stream_player_get_type ())
#define STREAM_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_STREAM_PLAYER, StreamPlayer))
#define STREAM_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_STREAM_PLAYER, StreamPlayerClass))
#define IS_STREAM_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_STREAM_PLAYER))
#define IS_STREAM_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_STREAM_PLAYER))
#define STREAM_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_STREAM_PLAYER, StreamPlayerClass))

typedef struct _StreamPlayer StreamPlayer;
typedef struct _StreamPlayerClass StreamPlayerClass;
typedef struct _StreamPlayerPrivate StreamPlayerPrivate;
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _gst_tag_list_unref0(var) ((var == NULL) ? NULL : (var = (gst_tag_list_unref (var), NULL)))
typedef struct _ParamSpecStreamPlayer ParamSpecStreamPlayer;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _stream_player_unref0(var) ((var == NULL) ? NULL : (var = (stream_player_unref (var), NULL)))

struct _StreamPlayer {
	GTypeInstance parent_instance;
	volatile int ref_count;
	StreamPlayerPrivate * priv;
	GstState state;
	gchar* s;
};

struct _StreamPlayerClass {
	GTypeClass parent_class;
	void (*finalize) (StreamPlayer *self);
};

struct _StreamPlayerPrivate {
	GMainLoop* loop;
};

struct _ParamSpecStreamPlayer {
	GParamSpec parent_instance;
};

extern GtkTextView* text_view;
GtkTextView* text_view = NULL;
extern GtkComboBox* combobox;
GtkComboBox* combobox = NULL;
extern GtkSpinButton* select_sura_box;
GtkSpinButton* select_sura_box = NULL;
extern GtkSpinButton* select_aya_box;
GtkSpinButton* select_aya_box = NULL;
extern GtkToggleButton* btn_play_mode;
GtkToggleButton* btn_play_mode = NULL;
extern gboolean cont;
gboolean cont = FALSE;
extern gdouble surano;
gdouble surano = (gdouble) 0;
extern gdouble ayano;
gdouble ayano = (gdouble) 0;
static gint StreamPlayer_private_offset;
static gpointer stream_player_parent_class = NULL;

GType column_get_type (void) G_GNUC_CONST;
gint getAddress (gint sura,
                 gint ayat);
gchar* getText (gint index,
                const gchar* path);
static void _vala_array_add1 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static void _vala_array_add2 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
void _vala_main (gchar** args,
                 gint args_length1);
static void _gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender,
                                        gpointer self);
static void __lambda4_ (void);
void on_btn_show_clicked (void);
static void ___lambda4__gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                               gpointer self);
static void __lambda5_ (void);
static void ___lambda5__gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                               gpointer self);
static void _on_btn_show_clicked_gtk_button_clicked (GtkButton* _sender,
                                              gpointer self);
void on_btn_next_clicked (void);
static void _on_btn_next_clicked_gtk_button_clicked (GtkButton* _sender,
                                              gpointer self);
void on_btn_listen_clicked (void);
static void _on_btn_listen_clicked_gtk_button_clicked (GtkButton* _sender,
                                                gpointer self);
void on_btn_play_mode_clicked (void);
static void _on_btn_play_mode_clicked_gtk_button_clicked (GtkButton* _sender,
                                                   gpointer self);
static void _vala_array_add3 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static void __lambda6_ (void);
static void ___lambda6__gtk_combo_box_changed (GtkComboBox* _sender,
                                        gpointer self);
gpointer stream_player_ref (gpointer instance);
void stream_player_unref (gpointer instance);
GParamSpec* param_spec_stream_player (const gchar* name,
                                      const gchar* nick,
                                      const gchar* blurb,
                                      GType object_type,
                                      GParamFlags flags);
void value_set_stream_player (GValue* value,
                              gpointer v_object);
void value_take_stream_player (GValue* value,
                               gpointer v_object);
gpointer value_get_stream_player (const GValue* value);
GType stream_player_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (StreamPlayer, stream_player_unref)
static void stream_player_foreach_tag (StreamPlayer* self,
                                GstTagList* list,
                                const gchar* tag);
static gboolean stream_player_bus_callback (StreamPlayer* self,
                                     GstBus* bus,
                                     GstMessage* message);
void stream_player_play (StreamPlayer* self,
                         const gchar* stream);
static inline void _dynamic_set_uri0 (GstElement* obj,
                        const gchar* value);
static gboolean _stream_player_bus_callback_gst_bus_func (GstBus* bus,
                                                   GstMessage* message,
                                                   gpointer self);
StreamPlayer* stream_player_new (void);
StreamPlayer* stream_player_construct (GType object_type);
static void stream_player_finalize (StreamPlayer * obj);
static GType stream_player_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

const gint ayatInSura[114] = {7, 286, 200, 176, 120, 165, 206, 75, 129, 109, 123, 111, 43, 52, 99, 128, 111, 110, 98, 135, 112, 78, 118, 64, 77, 227, 93, 88, 69, 60, 34, 30, 73, 54, 45, 83, 182, 88, 75, 85, 54, 53, 89, 59, 37, 35, 38, 29, 18, 45, 60, 49, 62, 55, 78, 96, 29, 22, 24, 13, 14, 11, 11, 18, 12, 12, 30, 52, 52, 44, 28, 28, 20, 56, 40, 31, 50, 40, 46, 42, 29, 19, 36, 25, 22, 17, 19, 26, 30, 20, 15, 21, 11, 8, 8, 19, 5, 8, 8, 11, 11, 8, 3, 9, 5, 4, 7, 3, 6, 3, 5, 4, 5, 6};

static GType
column_get_type_once (void)
{
	static const GEnumValue values[] = {{COLUMN_sura, "COLUMN_sura", "sura"}, {0, NULL, NULL}};
	GType column_type_id;
	column_type_id = g_enum_register_static ("Column", values);
	return column_type_id;
}

GType
column_get_type (void)
{
	static volatile gsize column_type_id__volatile = 0;
	if (g_once_init_enter (&column_type_id__volatile)) {
		GType column_type_id;
		column_type_id = column_get_type_once ();
		g_once_init_leave (&column_type_id__volatile, column_type_id);
	}
	return column_type_id__volatile;
}

gint
getAddress (gint sura,
            gint ayat)
{
	gint ayatsInPreviousSuras = 0;
	gint result = 0;
	ayatsInPreviousSuras = 0;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				gint _tmp2_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				if (!(i < sura)) {
					break;
				}
				_tmp2_ = ayatInSura[i];
				ayatsInPreviousSuras = ayatsInPreviousSuras + _tmp2_;
			}
		}
	}
	result = ayatsInPreviousSuras + ayat;
	return result;
}

static void
_vala_array_add1 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
_vala_array_add2 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

gchar*
getText (gint index,
         const gchar* path)
{
	GFile* file = NULL;
	GFile* _tmp0_;
	gchar** arrayOfAyat = NULL;
	gchar** _tmp1_;
	gint arrayOfAyat_length1;
	gint _arrayOfAyat_size_;
	GFile* _tmp2_;
	gchar** _tmp30_;
	gint _tmp30__length1;
	const gchar* _tmp31_;
	gchar* _tmp32_;
	GError* _inner_error0_ = NULL;
	gchar* result = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	_tmp0_ = g_file_new_for_path (path);
	file = _tmp0_;
	_tmp1_ = g_new0 (gchar*, 0 + 1);
	arrayOfAyat = _tmp1_;
	arrayOfAyat_length1 = 0;
	_arrayOfAyat_size_ = arrayOfAyat_length1;
	_tmp2_ = file;
	if (!g_file_query_exists (_tmp2_, NULL)) {
		FILE* _tmp3_;
		GFile* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp3_ = stderr;
		_tmp4_ = file;
		_tmp5_ = g_file_get_path (_tmp4_);
		_tmp6_ = _tmp5_;
		fprintf (_tmp3_, "File '%s' doesn't exist.\n", _tmp6_);
		_g_free0 (_tmp6_);
	}
	{
		GFileInputStream* _tmp7_ = NULL;
		GFile* _tmp8_;
		GFileInputStream* _tmp9_;
		GDataInputStream* dis = NULL;
		GDataInputStream* _tmp10_;
		gchar* line = NULL;
		_tmp8_ = file;
		_tmp9_ = g_file_read (_tmp8_, NULL, &_inner_error0_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp10_ = g_data_input_stream_new ((GInputStream*) _tmp7_);
		dis = _tmp10_;
		while (TRUE) {
			gchar* _tmp11_ = NULL;
			GDataInputStream* _tmp12_;
			gchar* _tmp13_;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			const gchar* _tmp16_;
			gchar** _tmp17_;
			gchar** _tmp18_;
			gchar** _tmp19_;
			gint _tmp19__length1;
			gboolean _tmp20_;
			_tmp12_ = dis;
			_tmp13_ = g_data_input_stream_read_line (_tmp12_, NULL, NULL, &_inner_error0_);
			_tmp11_ = _tmp13_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_free0 (line);
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp7_);
				goto __catch0_g_error;
			}
			_tmp14_ = _tmp11_;
			_tmp11_ = NULL;
			_g_free0 (line);
			line = _tmp14_;
			_tmp15_ = line;
			if (!(_tmp15_ != NULL)) {
				_g_free0 (_tmp11_);
				break;
			}
			_tmp16_ = line;
			_tmp18_ = _tmp17_ = g_strsplit (_tmp16_, "|", 0);
			_tmp19_ = _tmp18_;
			_tmp19__length1 = _vala_array_length (_tmp17_);
			_tmp20_ = _vala_array_length (_tmp17_) > 1;
			_tmp19_ = (_vala_array_free (_tmp19_, _tmp19__length1, (GDestroyNotify) g_free), NULL);
			if (_tmp20_) {
				const gchar* _tmp21_;
				gchar** _tmp22_;
				gchar** _tmp23_;
				gchar** _tmp24_;
				gint _tmp24__length1;
				const gchar* _tmp25_;
				gchar* _tmp26_;
				_tmp21_ = line;
				_tmp23_ = _tmp22_ = g_strsplit (_tmp21_, "|", 0);
				_tmp24_ = _tmp23_;
				_tmp24__length1 = _vala_array_length (_tmp22_);
				_tmp25_ = _tmp24_[2];
				_tmp26_ = g_strdup (_tmp25_);
				_vala_array_add1 (&arrayOfAyat, &arrayOfAyat_length1, &_arrayOfAyat_size_, _tmp26_);
				_tmp24_ = (_vala_array_free (_tmp24_, _tmp24__length1, (GDestroyNotify) g_free), NULL);
			} else {
				const gchar* _tmp27_;
				gchar* _tmp28_;
				_tmp27_ = line;
				_tmp28_ = g_strdup (_tmp27_);
				_vala_array_add2 (&arrayOfAyat, &arrayOfAyat_length1, &_arrayOfAyat_size_, _tmp28_);
			}
			_g_free0 (_tmp11_);
		}
		_g_free0 (line);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp7_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp29_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp29_ = e->message;
		g_error ("VerseViewer.vala:52: %s", _tmp29_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		arrayOfAyat = (_vala_array_free (arrayOfAyat, arrayOfAyat_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp30_ = arrayOfAyat;
	_tmp30__length1 = arrayOfAyat_length1;
	_tmp31_ = _tmp30_[index];
	_tmp32_ = g_strdup (_tmp31_);
	result = _tmp32_;
	arrayOfAyat = (_vala_array_free (arrayOfAyat, arrayOfAyat_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (file);
	return result;
}

static void
_gtk_main_quit_gtk_widget_destroy (GtkWidget* _sender,
                                   gpointer self)
{
	gtk_main_quit ();
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
__lambda4_ (void)
{
	GtkSpinButton* _tmp0_;
	GtkAdjustment* _tmp1_;
	GtkAdjustment* _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	GtkSpinButton* _tmp5_;
	gint _tmp6_;
	GtkSpinButton* _tmp7_;
	GtkAdjustment* _tmp8_;
	GtkAdjustment* _tmp9_;
	GtkComboBox* _tmp10_;
	_tmp0_ = select_sura_box;
	_tmp1_ = gtk_spin_button_get_adjustment (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = gtk_adjustment_get_value (_tmp2_);
	_tmp4_ = _tmp3_;
	surano = _tmp4_ - 1;
	_tmp5_ = select_aya_box;
	_tmp6_ = ayatInSura[(gint) surano];
	gtk_spin_button_set_range (_tmp5_, (gdouble) 1, (gdouble) _tmp6_);
	_tmp7_ = select_aya_box;
	_tmp8_ = gtk_spin_button_get_adjustment (_tmp7_);
	_tmp9_ = _tmp8_;
	gtk_adjustment_set_value (_tmp9_, (gdouble) 1);
	_tmp10_ = combobox;
	gtk_combo_box_set_active (_tmp10_, (gint) surano);
	on_btn_show_clicked ();
}

static void
___lambda4__gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                          gpointer self)
{
	__lambda4_ ();
}

static void
__lambda5_ (void)
{
	GtkSpinButton* _tmp0_;
	GtkAdjustment* _tmp1_;
	GtkAdjustment* _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	_tmp0_ = select_aya_box;
	_tmp1_ = gtk_spin_button_get_adjustment (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = gtk_adjustment_get_value (_tmp2_);
	_tmp4_ = _tmp3_;
	ayano = _tmp4_ - 1;
	on_btn_show_clicked ();
}

static void
___lambda5__gtk_adjustment_value_changed (GtkAdjustment* _sender,
                                          gpointer self)
{
	__lambda5_ ();
}

static void
_on_btn_show_clicked_gtk_button_clicked (GtkButton* _sender,
                                         gpointer self)
{
	on_btn_show_clicked ();
}

static void
_on_btn_next_clicked_gtk_button_clicked (GtkButton* _sender,
                                         gpointer self)
{
	on_btn_next_clicked ();
}

static void
_on_btn_listen_clicked_gtk_button_clicked (GtkButton* _sender,
                                           gpointer self)
{
	on_btn_listen_clicked ();
}

static void
_on_btn_play_mode_clicked_gtk_button_clicked (GtkButton* _sender,
                                              gpointer self)
{
	on_btn_play_mode_clicked ();
}

static void
_vala_array_add3 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}

static void
__lambda6_ (void)
{
	GtkSpinButton* _tmp0_;
	GtkAdjustment* _tmp1_;
	GtkAdjustment* _tmp2_;
	GtkComboBox* _tmp3_;
	_tmp0_ = select_sura_box;
	_tmp1_ = gtk_spin_button_get_adjustment (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = combobox;
	gtk_adjustment_set_value (_tmp2_, 1 + ((gdouble) gtk_combo_box_get_active (_tmp3_)));
}

static void
___lambda6__gtk_combo_box_changed (GtkComboBox* _sender,
                                   gpointer self)
{
	__lambda6_ ();
}

void
_vala_main (gchar** args,
            gint args_length1)
{
	GtkWindow* window_main = NULL;
	GtkWindow* _tmp0_;
	GtkCssProvider* css_provider = NULL;
	GtkCssProvider* _tmp6_;
	gchar* path = NULL;
	gchar* _tmp7_;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp8_;
	GdkScreen* _tmp9_;
	GFile* cssfile = NULL;
	GFile* _tmp10_;
	const gchar* _tmp11_;
	GtkBox* vbox_main = NULL;
	GtkBox* _tmp17_;
	GtkHeaderBar* header_bar = NULL;
	GtkHeaderBar* _tmp18_;
	GtkBox* hbox_nav = NULL;
	GtkBox* _tmp19_;
	GtkSpinButton* _tmp20_;
	GtkSpinButton* _tmp21_;
	GtkSpinButton* _tmp22_;
	GtkAdjustment* _tmp23_;
	GtkAdjustment* _tmp24_;
	GtkSpinButton* _tmp25_;
	GtkAdjustment* _tmp26_;
	GtkAdjustment* _tmp27_;
	GtkTextView* _tmp28_;
	GtkTextView* _tmp29_;
	GtkTextView* _tmp30_;
	GtkScrolledWindow* scroll = NULL;
	GtkScrolledWindow* _tmp31_;
	GtkScrolledWindow* _tmp32_;
	GtkScrolledWindow* _tmp33_;
	GtkButton* btn_show = NULL;
	GtkButton* _tmp34_;
	GtkButton* btn_next = NULL;
	GtkButton* _tmp35_;
	GtkButton* btn_listen = NULL;
	GtkButton* _tmp36_;
	GtkToggleButton* _tmp37_;
	GtkButton* _tmp38_;
	GtkButton* _tmp39_;
	GtkButton* _tmp40_;
	GtkToggleButton* _tmp41_;
	gchar** sura_list = NULL;
	gchar** _tmp42_;
	gint sura_list_length1;
	gint _sura_list_size_;
	GFile* file = NULL;
	GFile* _tmp43_;
	GFile* _tmp44_;
	GtkListStore* liststore = NULL;
	GtkListStore* _tmp57_;
	GtkListStore* _tmp67_;
	GtkComboBox* _tmp68_;
	GtkCellRendererText* cell = NULL;
	GtkCellRendererText* _tmp69_;
	GtkCellRendererPixbuf* cell_pb = NULL;
	GtkCellRendererPixbuf* _tmp70_;
	GtkComboBox* _tmp71_;
	GtkComboBox* _tmp72_;
	GtkComboBox* _tmp73_;
	GtkComboBox* _tmp74_;
	GtkComboBox* _tmp75_;
	GtkScrolledWindow* _tmp76_;
	GtkTextView* _tmp77_;
	GtkBox* _tmp78_;
	GtkScrolledWindow* _tmp79_;
	GtkBox* _tmp80_;
	GtkSpinButton* _tmp81_;
	GtkBox* _tmp82_;
	GtkSpinButton* _tmp83_;
	GtkBox* _tmp84_;
	GtkComboBox* _tmp85_;
	GtkBox* _tmp86_;
	GtkButton* _tmp87_;
	GtkBox* _tmp88_;
	GtkToggleButton* _tmp89_;
	GtkBox* _tmp90_;
	GtkStyleContext* _tmp91_;
	GtkHeaderBar* _tmp92_;
	GtkBox* _tmp93_;
	GtkHeaderBar* _tmp94_;
	GtkHeaderBar* _tmp95_;
	GtkBox* _tmp96_;
	GtkHeaderBar* _tmp97_;
	GtkSpinButton* _tmp98_;
	gint _tmp99_;
	GError* _inner_error0_ = NULL;
	gtk_init ((gint*) (&args_length1), &args);
	gst_init ((gint*) (&args_length1), &args);
	_tmp0_ = (GtkWindow*) gtk_window_new (GTK_WINDOW_TOPLEVEL);
	g_object_ref_sink (_tmp0_);
	window_main = _tmp0_;
	{
		GdkPixbuf* _tmp1_ = NULL;
		GdkPixbuf* _tmp2_;
		_tmp2_ = gdk_pixbuf_new_from_file ("icon.ico", &_inner_error0_);
		_tmp1_ = _tmp2_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		gtk_window_set_icon (window_main, _tmp1_);
		_g_object_unref0 (_tmp1_);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		FILE* _tmp3_;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = stderr;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		fprintf (_tmp3_, "Could not load application icon: %s\n", _tmp5_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (window_main);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	gtk_window_set_title (window_main, "Verse viewer");
	gtk_window_set_default_size (window_main, 400, 500);
	g_signal_connect ((GtkWidget*) window_main, "destroy", (GCallback) _gtk_main_quit_gtk_widget_destroy, NULL);
	_tmp6_ = gtk_css_provider_new ();
	css_provider = _tmp6_;
	_tmp7_ = g_strdup ("styleapp.css");
	path = _tmp7_;
	_tmp8_ = gtk_window_get_screen (window_main);
	_tmp9_ = _g_object_ref0 (_tmp8_);
	screen = _tmp9_;
	_tmp10_ = g_file_new_for_path ("styleapp.css");
	cssfile = _tmp10_;
	_tmp11_ = path;
	if (g_file_test (_tmp11_, G_FILE_TEST_EXISTS)) {
		{
			GtkCssProvider* _tmp12_;
			GFile* _tmp13_;
			GdkScreen* _tmp14_;
			GtkCssProvider* _tmp15_;
			_tmp12_ = css_provider;
			_tmp13_ = cssfile;
			gtk_css_provider_load_from_file (_tmp12_, _tmp13_, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				goto __catch1_g_error;
			}
			_tmp14_ = screen;
			_tmp15_ = css_provider;
			gtk_style_context_add_provider_for_screen (_tmp14_, (GtkStyleProvider*) _tmp15_, (guint) GTK_STYLE_PROVIDER_PRIORITY_USER);
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError* e = NULL;
			const gchar* _tmp16_;
			e = _inner_error0_;
			_inner_error0_ = NULL;
			_tmp16_ = e->message;
			g_error ("VerseViewer.vala:81: Cannot load CSS stylesheet: %s", _tmp16_);
			_g_error_free0 (e);
		}
		__finally1:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (cssfile);
			_g_object_unref0 (screen);
			_g_free0 (path);
			_g_object_unref0 (css_provider);
			_g_object_unref0 (window_main);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_tmp17_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_VERTICAL, 0);
	g_object_ref_sink (_tmp17_);
	vbox_main = _tmp17_;
	_tmp18_ = (GtkHeaderBar*) gtk_header_bar_new ();
	g_object_ref_sink (_tmp18_);
	header_bar = _tmp18_;
	_tmp19_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
	g_object_ref_sink (_tmp19_);
	hbox_nav = _tmp19_;
	_tmp20_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 1, (gdouble) 114, (gdouble) 1);
	g_object_ref_sink (_tmp20_);
	_g_object_unref0 (select_sura_box);
	select_sura_box = _tmp20_;
	_tmp21_ = (GtkSpinButton*) gtk_spin_button_new_with_range ((gdouble) 1, (gdouble) 300, (gdouble) 1);
	g_object_ref_sink (_tmp21_);
	_g_object_unref0 (select_aya_box);
	select_aya_box = _tmp21_;
	_tmp22_ = select_sura_box;
	_tmp23_ = gtk_spin_button_get_adjustment (_tmp22_);
	_tmp24_ = _tmp23_;
	g_signal_connect (_tmp24_, "value-changed", (GCallback) ___lambda4__gtk_adjustment_value_changed, NULL);
	_tmp25_ = select_aya_box;
	_tmp26_ = gtk_spin_button_get_adjustment (_tmp25_);
	_tmp27_ = _tmp26_;
	g_signal_connect (_tmp27_, "value-changed", (GCallback) ___lambda5__gtk_adjustment_value_changed, NULL);
	_tmp28_ = (GtkTextView*) gtk_text_view_new ();
	g_object_ref_sink (_tmp28_);
	_g_object_unref0 (text_view);
	text_view = _tmp28_;
	_tmp29_ = text_view;
	gtk_text_view_set_editable (_tmp29_, FALSE);
	_tmp30_ = text_view;
	gtk_text_view_set_cursor_visible (_tmp30_, FALSE);
	_tmp31_ = (GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL);
	g_object_ref_sink (_tmp31_);
	scroll = _tmp31_;
	_tmp32_ = scroll;
	gtk_scrolled_window_set_policy (_tmp32_, GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
	_tmp33_ = scroll;
	gtk_scrolled_window_set_placement (_tmp33_, GTK_CORNER_TOP_RIGHT);
	_tmp34_ = (GtkButton*) gtk_button_new_with_label ("Show");
	g_object_ref_sink (_tmp34_);
	btn_show = _tmp34_;
	_tmp35_ = (GtkButton*) gtk_button_new_with_label ("Next");
	g_object_ref_sink (_tmp35_);
	btn_next = _tmp35_;
	_tmp36_ = (GtkButton*) gtk_button_new_with_label ("▶️");
	g_object_ref_sink (_tmp36_);
	btn_listen = _tmp36_;
	_tmp37_ = (GtkToggleButton*) gtk_toggle_button_new_with_label ("⏩");
	g_object_ref_sink (_tmp37_);
	_g_object_unref0 (btn_play_mode);
	btn_play_mode = _tmp37_;
	_tmp38_ = btn_show;
	g_signal_connect (_tmp38_, "clicked", (GCallback) _on_btn_show_clicked_gtk_button_clicked, NULL);
	_tmp39_ = btn_next;
	g_signal_connect (_tmp39_, "clicked", (GCallback) _on_btn_next_clicked_gtk_button_clicked, NULL);
	_tmp40_ = btn_listen;
	g_signal_connect (_tmp40_, "clicked", (GCallback) _on_btn_listen_clicked_gtk_button_clicked, NULL);
	_tmp41_ = btn_play_mode;
	g_signal_connect ((GtkButton*) _tmp41_, "clicked", (GCallback) _on_btn_play_mode_clicked_gtk_button_clicked, NULL);
	_tmp42_ = g_new0 (gchar*, 0 + 1);
	sura_list = _tmp42_;
	sura_list_length1 = 0;
	_sura_list_size_ = sura_list_length1;
	_tmp43_ = g_file_new_for_path ("text/sura_list_en.txt");
	file = _tmp43_;
	_tmp44_ = file;
	if (!g_file_query_exists (_tmp44_, NULL)) {
	}
	{
		GFileInputStream* _tmp45_ = NULL;
		GFile* _tmp46_;
		GFileInputStream* _tmp47_;
		GDataInputStream* dis = NULL;
		GDataInputStream* _tmp48_;
		gchar* line = NULL;
		_tmp46_ = file;
		_tmp47_ = g_file_read (_tmp46_, NULL, &_inner_error0_);
		_tmp45_ = _tmp47_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch2_g_error;
		}
		_tmp48_ = g_data_input_stream_new ((GInputStream*) _tmp45_);
		dis = _tmp48_;
		while (TRUE) {
			gchar* _tmp49_ = NULL;
			GDataInputStream* _tmp50_;
			gchar* _tmp51_;
			gchar* _tmp52_;
			const gchar* _tmp53_;
			const gchar* _tmp54_;
			gchar* _tmp55_;
			_tmp50_ = dis;
			_tmp51_ = g_data_input_stream_read_line (_tmp50_, NULL, NULL, &_inner_error0_);
			_tmp49_ = _tmp51_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_free0 (line);
				_g_object_unref0 (dis);
				_g_object_unref0 (_tmp45_);
				goto __catch2_g_error;
			}
			_tmp52_ = _tmp49_;
			_tmp49_ = NULL;
			_g_free0 (line);
			line = _tmp52_;
			_tmp53_ = line;
			if (!(_tmp53_ != NULL)) {
				_g_free0 (_tmp49_);
				break;
			}
			_tmp54_ = line;
			_tmp55_ = g_strdup (_tmp54_);
			_vala_array_add3 (&sura_list, &sura_list_length1, &_sura_list_size_, _tmp55_);
			_g_free0 (_tmp49_);
		}
		_g_free0 (line);
		_g_object_unref0 (dis);
		_g_object_unref0 (_tmp45_);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp56_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp56_ = e->message;
		g_error ("VerseViewer.vala:130: %s", _tmp56_);
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (file);
		sura_list = (_vala_array_free (sura_list, sura_list_length1, (GDestroyNotify) g_free), NULL);
		_g_object_unref0 (btn_listen);
		_g_object_unref0 (btn_next);
		_g_object_unref0 (btn_show);
		_g_object_unref0 (scroll);
		_g_object_unref0 (hbox_nav);
		_g_object_unref0 (header_bar);
		_g_object_unref0 (vbox_main);
		_g_object_unref0 (cssfile);
		_g_object_unref0 (screen);
		_g_free0 (path);
		_g_object_unref0 (css_provider);
		_g_object_unref0 (window_main);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	_tmp57_ = gtk_list_store_new (1, G_TYPE_STRING, -1);
	liststore = _tmp57_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp58_ = FALSE;
			_tmp58_ = TRUE;
			while (TRUE) {
				gchar** _tmp60_;
				gint _tmp60__length1;
				GtkTreeIter iter = {0};
				GtkListStore* _tmp61_;
				GtkTreeIter _tmp62_ = {0};
				GtkListStore* _tmp63_;
				GtkTreeIter _tmp64_;
				gchar** _tmp65_;
				gint _tmp65__length1;
				const gchar* _tmp66_;
				if (!_tmp58_) {
					gint _tmp59_;
					_tmp59_ = i;
					i = _tmp59_ + 1;
				}
				_tmp58_ = FALSE;
				_tmp60_ = sura_list;
				_tmp60__length1 = sura_list_length1;
				if (!(i < _tmp60__length1)) {
					break;
				}
				_tmp61_ = liststore;
				gtk_list_store_append (_tmp61_, &_tmp62_);
				iter = _tmp62_;
				_tmp63_ = liststore;
				_tmp64_ = iter;
				_tmp65_ = sura_list;
				_tmp65__length1 = sura_list_length1;
				_tmp66_ = _tmp65_[i];
				gtk_list_store_set (_tmp63_, &_tmp64_, COLUMN_sura, _tmp66_, -1);
			}
		}
	}
	_tmp67_ = liststore;
	_tmp68_ = (GtkComboBox*) gtk_combo_box_new_with_model ((GtkTreeModel*) _tmp67_);
	g_object_ref_sink (_tmp68_);
	_g_object_unref0 (combobox);
	combobox = _tmp68_;
	_tmp69_ = (GtkCellRendererText*) gtk_cell_renderer_text_new ();
	g_object_ref_sink (_tmp69_);
	cell = _tmp69_;
	_tmp70_ = (GtkCellRendererPixbuf*) gtk_cell_renderer_pixbuf_new ();
	g_object_ref_sink (_tmp70_);
	cell_pb = _tmp70_;
	_tmp71_ = combobox;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp71_, (GtkCellRenderer*) cell_pb, FALSE);
	_tmp72_ = combobox;
	gtk_cell_layout_pack_start ((GtkCellLayout*) _tmp72_, (GtkCellRenderer*) cell, FALSE);
	_tmp73_ = combobox;
	gtk_cell_layout_set_attributes ((GtkCellLayout*) _tmp73_, (GtkCellRenderer*) cell, "text", COLUMN_sura, NULL);
	_tmp74_ = combobox;
	gtk_combo_box_set_active (_tmp74_, (gint) surano);
	_tmp75_ = combobox;
	g_signal_connect (_tmp75_, "changed", (GCallback) ___lambda6__gtk_combo_box_changed, NULL);
	_tmp76_ = scroll;
	_tmp77_ = text_view;
	gtk_container_add ((GtkContainer*) _tmp76_, (GtkWidget*) _tmp77_);
	_tmp78_ = vbox_main;
	_tmp79_ = scroll;
	gtk_box_pack_start (_tmp78_, (GtkWidget*) _tmp79_, TRUE, TRUE, (guint) 0);
	_tmp80_ = hbox_nav;
	_tmp81_ = select_sura_box;
	gtk_container_add ((GtkContainer*) _tmp80_, (GtkWidget*) _tmp81_);
	_tmp82_ = hbox_nav;
	_tmp83_ = select_aya_box;
	gtk_container_add ((GtkContainer*) _tmp82_, (GtkWidget*) _tmp83_);
	_tmp84_ = hbox_nav;
	_tmp85_ = combobox;
	gtk_container_add ((GtkContainer*) _tmp84_, (GtkWidget*) _tmp85_);
	_tmp86_ = hbox_nav;
	_tmp87_ = btn_listen;
	gtk_container_add ((GtkContainer*) _tmp86_, (GtkWidget*) _tmp87_);
	_tmp88_ = hbox_nav;
	_tmp89_ = btn_play_mode;
	gtk_container_add ((GtkContainer*) _tmp88_, (GtkWidget*) _tmp89_);
	_tmp90_ = hbox_nav;
	_tmp91_ = gtk_widget_get_style_context ((GtkWidget*) _tmp90_);
	gtk_style_context_add_class (_tmp91_, "my_combobox");
	_tmp92_ = header_bar;
	_tmp93_ = hbox_nav;
	gtk_container_add ((GtkContainer*) _tmp92_, (GtkWidget*) _tmp93_);
	_tmp94_ = header_bar;
	gtk_header_bar_set_show_close_button (_tmp94_, TRUE);
	_tmp95_ = header_bar;
	gtk_widget_show_all ((GtkWidget*) _tmp95_);
	_tmp96_ = vbox_main;
	gtk_container_add ((GtkContainer*) window_main, (GtkWidget*) _tmp96_);
	_tmp97_ = header_bar;
	gtk_window_set_titlebar (window_main, (GtkWidget*) _tmp97_);
	gtk_widget_show_all ((GtkWidget*) window_main);
	_tmp98_ = select_aya_box;
	_tmp99_ = ayatInSura[(gint) surano];
	gtk_spin_button_set_range (_tmp98_, (gdouble) 1, (gdouble) _tmp99_);
	on_btn_show_clicked ();
	gtk_main ();
	_g_object_unref0 (cell_pb);
	_g_object_unref0 (cell);
	_g_object_unref0 (liststore);
	_g_object_unref0 (file);
	sura_list = (_vala_array_free (sura_list, sura_list_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (btn_listen);
	_g_object_unref0 (btn_next);
	_g_object_unref0 (btn_show);
	_g_object_unref0 (scroll);
	_g_object_unref0 (hbox_nav);
	_g_object_unref0 (header_bar);
	_g_object_unref0 (vbox_main);
	_g_object_unref0 (cssfile);
	_g_object_unref0 (screen);
	_g_free0 (path);
	_g_object_unref0 (css_provider);
	_g_object_unref0 (window_main);
}

int
main (int argc,
      char ** argv)
{
	_vala_main (argv, argc);
	return 0;
}

void
on_btn_show_clicked (void)
{
	gchar* q = NULL;
	gchar* e = NULL;
	gchar* b = NULL;
	gchar* qx = NULL;
	gchar* ex = NULL;
	gchar* bx = NULL;
	gchar* empty = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	GtkTextIter start = {0};
	GtkTextIter end = {0};
	GtkTextView* _tmp7_;
	GtkTextBuffer* _tmp8_;
	GtkTextBuffer* _tmp9_;
	GtkTextIter _tmp10_ = {0};
	GtkTextView* _tmp11_;
	GtkTextBuffer* _tmp12_;
	GtkTextBuffer* _tmp13_;
	GtkTextIter _tmp14_ = {0};
	GtkTextView* _tmp15_;
	GtkTextBuffer* _tmp16_;
	GtkTextBuffer* _tmp17_;
	GtkTextView* _tmp18_;
	GtkTextBuffer* _tmp19_;
	GtkTextBuffer* _tmp20_;
	GtkTextView* _tmp21_;
	GtkTextBuffer* _tmp22_;
	GtkTextBuffer* _tmp23_;
	GtkTextView* _tmp24_;
	GtkTextBuffer* _tmp25_;
	GtkTextBuffer* _tmp26_;
	GtkTextView* _tmp27_;
	GtkTextBuffer* _tmp28_;
	GtkTextBuffer* _tmp29_;
	GtkTextView* _tmp30_;
	GtkTextBuffer* _tmp31_;
	GtkTextBuffer* _tmp32_;
	GtkTextView* _tmp33_;
	GtkStyleContext* _tmp34_;
	GtkTextView* _tmp35_;
	GtkTextView* _tmp36_;
	_tmp0_ = getText (getAddress ((gint) surano, (gint) ayano), "text/quran/quran-uthmani.txt");
	_g_free0 (q);
	q = _tmp0_;
	_tmp1_ = getText (getAddress ((gint) surano, (gint) ayano), "text/trans/en.yusufali.trans/en.yusufali.txt");
	_g_free0 (e);
	e = _tmp1_;
	_tmp2_ = getText (getAddress ((gint) surano, (gint) ayano), "text/trans/bn.bengali.trans/bn.bengali.txt");
	_g_free0 (b);
	b = _tmp2_;
	_tmp3_ = g_strdup_printf ("<span face=\"Al Qalam Quran Majeed\" size=\"small\" style=\"normal\" w" \
"eight=\"normal\">%s\n" \
"</span>", " ");
	_g_free0 (empty);
	empty = _tmp3_;
	_tmp4_ = g_strdup_printf ("<span face=\"Al Qalam Quran Majeed\" size=\"xx-large\" style=\"normal\"" \
" weight=\"normal\">%s\n" \
"</span>", q);
	_g_free0 (qx);
	qx = _tmp4_;
	_tmp5_ = g_strdup_printf ("<span face=\"Georgia\" size=\"medium\" weight=\"light\">%s\n</span>", e);
	_g_free0 (ex);
	ex = _tmp5_;
	_tmp6_ = g_strdup_printf ("<span face=\"Lohit Bengali\" size=\"medium\" weight=\"normal\">%s\n" \
"</span>", b);
	_g_free0 (bx);
	bx = _tmp6_;
	_tmp7_ = text_view;
	_tmp8_ = gtk_text_view_get_buffer (_tmp7_);
	_tmp9_ = _tmp8_;
	gtk_text_buffer_get_start_iter (_tmp9_, &_tmp10_);
	start = _tmp10_;
	_tmp11_ = text_view;
	_tmp12_ = gtk_text_view_get_buffer (_tmp11_);
	_tmp13_ = _tmp12_;
	gtk_text_buffer_get_end_iter (_tmp13_, &_tmp14_);
	end = _tmp14_;
	_tmp15_ = text_view;
	_tmp16_ = gtk_text_view_get_buffer (_tmp15_);
	_tmp17_ = _tmp16_;
	gtk_text_buffer_delete (_tmp17_, &start, &end);
	_tmp18_ = text_view;
	_tmp19_ = gtk_text_view_get_buffer (_tmp18_);
	_tmp20_ = _tmp19_;
	gtk_text_buffer_insert_markup (_tmp20_, &end, empty, -1);
	_tmp21_ = text_view;
	_tmp22_ = gtk_text_view_get_buffer (_tmp21_);
	_tmp23_ = _tmp22_;
	gtk_text_buffer_insert_markup (_tmp23_, &end, qx, -1);
	_tmp24_ = text_view;
	_tmp25_ = gtk_text_view_get_buffer (_tmp24_);
	_tmp26_ = _tmp25_;
	gtk_text_buffer_insert_markup (_tmp26_, &end, empty, -1);
	_tmp27_ = text_view;
	_tmp28_ = gtk_text_view_get_buffer (_tmp27_);
	_tmp29_ = _tmp28_;
	gtk_text_buffer_insert_markup (_tmp29_, &end, bx, -1);
	_tmp30_ = text_view;
	_tmp31_ = gtk_text_view_get_buffer (_tmp30_);
	_tmp32_ = _tmp31_;
	gtk_text_buffer_insert_markup (_tmp32_, &end, ex, -1);
	_tmp33_ = text_view;
	_tmp34_ = gtk_widget_get_style_context ((GtkWidget*) _tmp33_);
	gtk_style_context_add_class (_tmp34_, "my_class");
	_tmp35_ = text_view;
	gtk_text_view_set_wrap_mode (_tmp35_, GTK_WRAP_WORD);
	_tmp36_ = text_view;
	gtk_text_view_set_justification (_tmp36_, GTK_JUSTIFY_CENTER);
	_g_free0 (empty);
	_g_free0 (bx);
	_g_free0 (ex);
	_g_free0 (qx);
	_g_free0 (b);
	_g_free0 (e);
	_g_free0 (q);
}

static inline gpointer
stream_player_get_instance_private (StreamPlayer* self)
{
	return G_STRUCT_MEMBER_P (self, StreamPlayer_private_offset);
}

static void
stream_player_foreach_tag (StreamPlayer* self,
                           GstTagList* list,
                           const gchar* tag)
{
	const gchar* _tmp0_;
	GQuark _tmp2_ = 0U;
	static GQuark _tmp1_label0 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (list != NULL);
	g_return_if_fail (tag != NULL);
	_tmp0_ = tag;
	_tmp2_ = (NULL == _tmp0_) ? 0 : g_quark_from_string (_tmp0_);
	if (_tmp2_ == ((0 != _tmp1_label0) ? _tmp1_label0 : (_tmp1_label0 = g_quark_from_static_string ("title")))) {
		switch (0) {
			default:
			{
				gchar* tag_string = NULL;
				gchar* _tmp3_ = NULL;
				FILE* _tmp4_;
				const gchar* _tmp5_;
				gst_tag_list_get_string (list, tag, &_tmp3_);
				_g_free0 (tag_string);
				tag_string = _tmp3_;
				_tmp4_ = stdout;
				_tmp5_ = tag_string;
				fprintf (_tmp4_, "tag: %s = %s\n", tag, _tmp5_);
				_g_free0 (tag_string);
				break;
			}
		}
	} else {
		switch (0) {
			default:
			{
				break;
			}
		}
	}
}

static gboolean
stream_player_bus_callback (StreamPlayer* self,
                            GstBus* bus,
                            GstMessage* message)
{
	GstMessageType _tmp0_;
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (bus != NULL, FALSE);
	g_return_val_if_fail (message != NULL, FALSE);
	_tmp0_ = message->type;
	switch (_tmp0_) {
		case GST_MESSAGE_ERROR:
		{
			GError* err = NULL;
			gchar* debug = NULL;
			GError* _tmp1_ = NULL;
			gchar* _tmp2_ = NULL;
			FILE* _tmp3_;
			GError* _tmp4_;
			const gchar* _tmp5_;
			GMainLoop* _tmp6_;
			gst_message_parse_error (message, &_tmp1_, &_tmp2_);
			_g_error_free0 (err);
			err = _tmp1_;
			_g_free0 (debug);
			debug = _tmp2_;
			_tmp3_ = stdout;
			_tmp4_ = err;
			_tmp5_ = _tmp4_->message;
			fprintf (_tmp3_, "Error: %s\n", _tmp5_);
			_tmp6_ = self->priv->loop;
			g_main_loop_quit (_tmp6_);
			_g_free0 (debug);
			_g_error_free0 (err);
			break;
		}
		case GST_MESSAGE_EOS:
		{
			FILE* _tmp7_;
			_tmp7_ = stdout;
			fprintf (_tmp7_, "end of stream\n");
			if (cont) {
				on_btn_next_clicked ();
				on_btn_listen_clicked ();
			} else {
			}
			break;
		}
		case GST_MESSAGE_STATE_CHANGED:
		{
			GstState oldstate = 0;
			GstState newstate = 0;
			GstState pending = 0;
			GstState _tmp8_ = 0;
			GstState _tmp9_ = 0;
			GstState _tmp10_ = 0;
			FILE* _tmp11_;
			GstState _tmp12_;
			GEnumValue* _tmp13_;
			GstState _tmp14_;
			GEnumValue* _tmp15_;
			GstState _tmp16_;
			GEnumValue* _tmp17_;
			gst_message_parse_state_changed (message, &_tmp8_, &_tmp9_, &_tmp10_);
			oldstate = _tmp8_;
			newstate = _tmp9_;
			pending = _tmp10_;
			_tmp11_ = stdout;
			_tmp12_ = oldstate;
			_tmp13_ = g_enum_get_value (g_type_class_ref (gst_state_get_type ()), _tmp12_);
			_tmp14_ = newstate;
			_tmp15_ = g_enum_get_value (g_type_class_ref (gst_state_get_type ()), _tmp14_);
			_tmp16_ = pending;
			_tmp17_ = g_enum_get_value (g_type_class_ref (gst_state_get_type ()), _tmp16_);
			fprintf (_tmp11_, "state changed: %s->%s:%s\n", (_tmp13_ != NULL) ? _tmp13_->value_name : NULL, (_tmp15_ != NULL) ? _tmp15_->value_name : NULL, (_tmp17_ != NULL) ? _tmp17_->value_name : NULL);
			break;
		}
		case GST_MESSAGE_TAG:
		{
			GstTagList* tag_list = NULL;
			FILE* _tmp18_;
			GstTagList* _tmp19_ = NULL;
			GstTagList* _tmp20_;
			_tmp18_ = stdout;
			fprintf (_tmp18_, "taglist found\n");
			gst_message_parse_tag (message, &_tmp19_);
			_gst_tag_list_unref0 (tag_list);
			tag_list = _tmp19_;
			_tmp20_ = tag_list;
			gst_tag_list_foreach (_tmp20_, (GstTagForeachFunc) stream_player_foreach_tag, self);
			_gst_tag_list_unref0 (tag_list);
			break;
		}
		default:
		{
			break;
		}
	}
	result = TRUE;
	return result;
}

static inline void
_dynamic_set_uri0 (GstElement* obj,
                   const gchar* value)
{
	g_object_set (obj, "uri", value, NULL);
}

static gboolean
_stream_player_bus_callback_gst_bus_func (GstBus* bus,
                                          GstMessage* message,
                                          gpointer self)
{
	gboolean result;
	result = stream_player_bus_callback ((StreamPlayer*) self, bus, message);
	return result;
}

void
stream_player_play (StreamPlayer* self,
                    const gchar* stream)
{
	GstElement* play = NULL;
	GstElement* _tmp0_;
	GstBus* bus = NULL;
	GstBus* _tmp1_;
	GstState _tmp2_ = 0;
	GstState _tmp3_;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	GMainLoop* _tmp6_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (stream != NULL);
	_tmp0_ = gst_element_factory_make ("playbin", "play");
	if (_tmp0_ != NULL) {
		g_object_ref_sink (_tmp0_);
	}
	play = _tmp0_;
	_dynamic_set_uri0 (play, stream);
	_tmp1_ = gst_element_get_bus (play);
	bus = _tmp1_;
	gst_bus_add_watch_full (bus, G_PRIORITY_HIGH_IDLE, _stream_player_bus_callback_gst_bus_func, stream_player_ref (self), stream_player_unref);
	gst_element_set_state (play, GST_STATE_NULL);
	gst_element_set_state (play, GST_STATE_READY);
	gst_element_set_state (play, GST_STATE_PLAYING);
	gst_element_get_state (play, &_tmp2_, NULL, GST_CLOCK_TIME_NONE);
	self->state = _tmp2_;
	_tmp3_ = self->state;
	_tmp4_ = gst_element_state_get_name (_tmp3_);
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->s);
	self->s = _tmp5_;
	_tmp6_ = self->priv->loop;
	g_main_loop_run (_tmp6_);
	_g_object_unref0 (bus);
	_g_object_unref0 (play);
}

StreamPlayer*
stream_player_construct (GType object_type)
{
	StreamPlayer* self = NULL;
	self = (StreamPlayer*) g_type_create_instance (object_type);
	return self;
}

StreamPlayer*
stream_player_new (void)
{
	return stream_player_construct (TYPE_STREAM_PLAYER);
}

static void
value_stream_player_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_stream_player_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		stream_player_unref (value->data[0].v_pointer);
	}
}

static void
value_stream_player_copy_value (const GValue* src_value,
                                GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = stream_player_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_stream_player_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_stream_player_collect_value (GValue* value,
                                   guint n_collect_values,
                                   GTypeCValue* collect_values,
                                   guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		StreamPlayer * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = stream_player_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_stream_player_lcopy_value (const GValue* value,
                                 guint n_collect_values,
                                 GTypeCValue* collect_values,
                                 guint collect_flags)
{
	StreamPlayer ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = stream_player_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_stream_player (const gchar* name,
                          const gchar* nick,
                          const gchar* blurb,
                          GType object_type,
                          GParamFlags flags)
{
	ParamSpecStreamPlayer* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_STREAM_PLAYER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_stream_player (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_STREAM_PLAYER), NULL);
	return value->data[0].v_pointer;
}

void
value_set_stream_player (GValue* value,
                         gpointer v_object)
{
	StreamPlayer * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_STREAM_PLAYER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_STREAM_PLAYER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		stream_player_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		stream_player_unref (old);
	}
}

void
value_take_stream_player (GValue* value,
                          gpointer v_object)
{
	StreamPlayer * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_STREAM_PLAYER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_STREAM_PLAYER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		stream_player_unref (old);
	}
}

static void
stream_player_class_init (StreamPlayerClass * klass,
                          gpointer klass_data)
{
	stream_player_parent_class = g_type_class_peek_parent (klass);
	((StreamPlayerClass *) klass)->finalize = stream_player_finalize;
	g_type_class_adjust_private_offset (klass, &StreamPlayer_private_offset);
}

static void
stream_player_instance_init (StreamPlayer * self,
                             gpointer klass)
{
	GMainLoop* _tmp0_;
	self->priv = stream_player_get_instance_private (self);
	_tmp0_ = g_main_loop_new (NULL, FALSE);
	self->priv->loop = _tmp0_;
	self->ref_count = 1;
}

static void
stream_player_finalize (StreamPlayer * obj)
{
	StreamPlayer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_STREAM_PLAYER, StreamPlayer);
	g_signal_handlers_destroy (self);
	_g_free0 (self->s);
	_g_main_loop_unref0 (self->priv->loop);
}

static GType
stream_player_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_stream_player_init, value_stream_player_free_value, value_stream_player_copy_value, value_stream_player_peek_pointer, "p", value_stream_player_collect_value, "p", value_stream_player_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (StreamPlayerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) stream_player_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (StreamPlayer), 0, (GInstanceInitFunc) stream_player_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType stream_player_type_id;
	stream_player_type_id = g_type_register_fundamental (g_type_fundamental_next (), "StreamPlayer", &g_define_type_info, &g_define_type_fundamental_info, 0);
	StreamPlayer_private_offset = g_type_add_instance_private (stream_player_type_id, sizeof (StreamPlayerPrivate));
	return stream_player_type_id;
}

GType
stream_player_get_type (void)
{
	static volatile gsize stream_player_type_id__volatile = 0;
	if (g_once_init_enter (&stream_player_type_id__volatile)) {
		GType stream_player_type_id;
		stream_player_type_id = stream_player_get_type_once ();
		g_once_init_leave (&stream_player_type_id__volatile, stream_player_type_id);
	}
	return stream_player_type_id__volatile;
}

gpointer
stream_player_ref (gpointer instance)
{
	StreamPlayer * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
stream_player_unref (gpointer instance)
{
	StreamPlayer * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		STREAM_PLAYER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError* _inner_error0_ = NULL;
	gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = (*((gchar*) old)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (self);
		result = _tmp2_;
		return result;
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp3_ = g_regex_escape_string (old, -1);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error0_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		regex = _tmp6_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp8_ = regex;
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error0_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		result = _tmp10_;
		_g_free0 (_tmp7_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		g_clear_error (&_inner_error0_);
		g_assert_not_reached ();
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return NULL;
}

void
on_btn_listen_clicked (void)
{
	StreamPlayer* player = NULL;
	StreamPlayer* _tmp0_;
	StreamPlayer* _tmp1_;
	const gchar* _tmp2_;
	gchar* formatted_sura = NULL;
	gchar* _tmp3_;
	gchar* formatted_aya = NULL;
	gchar* _tmp4_;
	gchar* dir = NULL;
	gchar* _tmp5_;
	gchar* filename = NULL;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* _tmp20_;
	const gchar* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	gchar* _tmp25_;
	StreamPlayer* _tmp26_;
	const gchar* _tmp27_;
	gchar* _tmp28_;
	gchar* _tmp29_;
	_tmp0_ = stream_player_new ();
	player = _tmp0_;
	_tmp1_ = player;
	_tmp2_ = _tmp1_->s;
	g_print ("%s", _tmp2_);
	_tmp3_ = g_strdup_printf ("%03d", ((gint) surano) + 1);
	formatted_sura = _tmp3_;
	_tmp4_ = g_strdup_printf ("%03d", ((gint) ayano) + 1);
	formatted_aya = _tmp4_;
	_tmp5_ = g_strdup ("/afasy-64kbps-offline/");
	_g_free0 (dir);
	dir = _tmp5_;
	_tmp6_ = g_get_current_dir ();
	_tmp7_ = _tmp6_;
	_tmp8_ = g_strconcat ("file:///", _tmp7_, NULL);
	_tmp9_ = _tmp8_;
	_tmp10_ = dir;
	_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL);
	_tmp12_ = _tmp11_;
	_tmp13_ = formatted_sura;
	_tmp14_ = g_strconcat (_tmp12_, _tmp13_, NULL);
	_tmp15_ = _tmp14_;
	_tmp16_ = g_strconcat (_tmp15_, "/", NULL);
	_tmp17_ = _tmp16_;
	_tmp18_ = formatted_sura;
	_tmp19_ = g_strconcat (_tmp17_, _tmp18_, NULL);
	_tmp20_ = _tmp19_;
	_tmp21_ = formatted_aya;
	_tmp22_ = g_strconcat (_tmp20_, _tmp21_, NULL);
	_tmp23_ = _tmp22_;
	_tmp24_ = g_strconcat (_tmp23_, ".mp3", NULL);
	_tmp25_ = _tmp24_;
	_g_free0 (_tmp23_);
	_g_free0 (_tmp20_);
	_g_free0 (_tmp17_);
	_g_free0 (_tmp15_);
	_g_free0 (_tmp12_);
	_g_free0 (_tmp9_);
	_g_free0 (_tmp7_);
	filename = _tmp25_;
	_tmp26_ = player;
	_tmp27_ = filename;
	_tmp28_ = string_replace (_tmp27_, "\\", "/");
	_tmp29_ = _tmp28_;
	stream_player_play (_tmp26_, _tmp29_);
	_g_free0 (_tmp29_);
	while (TRUE) {
		StreamPlayer* _tmp30_;
		const gchar* _tmp31_;
		_tmp30_ = player;
		_tmp31_ = _tmp30_->s;
		if (!(g_strcmp0 (_tmp31_, "PLAYING") != 0)) {
			break;
		}
	}
	_g_free0 (filename);
	_g_free0 (dir);
	_g_free0 (formatted_aya);
	_g_free0 (formatted_sura);
	_stream_player_unref0 (player);
}

void
on_btn_next_clicked (void)
{
	gint _tmp0_;
	_tmp0_ = ayatInSura[(gint) surano];
	if (ayano < ((gdouble) (_tmp0_ - 1))) {
		GtkSpinButton* _tmp1_;
		_tmp1_ = select_aya_box;
		gtk_spin_button_spin (_tmp1_, GTK_SPIN_STEP_FORWARD, (gdouble) 1);
	} else {
		GtkSpinButton* _tmp2_;
		_tmp2_ = select_sura_box;
		gtk_spin_button_spin (_tmp2_, GTK_SPIN_STEP_FORWARD, (gdouble) 1);
	}
}

static gchar*
bool_to_string (gboolean self)
{
	gchar* result = NULL;
	if (self) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup ("true");
		result = _tmp0_;
		return result;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("false");
		result = _tmp1_;
		return result;
	}
}

void
on_btn_play_mode_clicked (void)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	if (cont == TRUE) {
		cont = FALSE;
	} else {
		cont = TRUE;
	}
	_tmp0_ = bool_to_string (cont);
	_tmp1_ = _tmp0_;
	g_print ("%s", _tmp1_);
	_g_free0 (_tmp1_);
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_vala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

